# 200513

this : 자기참조변수, 예약어 (자바스크립트 엔진에서 할당한 값만 들어갈 수 있다.)

---

## 실행 컨텍스트

돔을 배우고 이벤트핸들러를 배울 때, 어떻게 동작하는지 알기위해 알아야 실행 컨텍스트를 알아야 한다.
비동기함수 (타이머함수같은거) 비동기가 동작하는것을 알기 위해 실행 컨텍스트를 알아야 한다.

텍스트파일(소스 코드)에서 만드는중에 실행되는게 아니라 실행을 시켜야 실행한다.
자바스크립트 파일을 html에 src로 path 정해주면, html실행하면 js가 불러오자마자 실행

텍스트파일은 순수한 텍스트 파일일 뿐,
읽어들어서 해석하고 실행시켜주는것이 자바스크립트 엔진.

어떠한 실행 컨텍스트를 만드느냐에 따라 소스 코드의 타입이 4가지로 나뉜다.

전역 : 코드의 가장 top level
함수 코드 : 키워드 함수이름 매개변수목록 코드블록안 함수몸체에 있는 코드

```javascript
function foo () {
  //
  function bar () {
    // 이곳은 foo함수 소속이지만 bar함수코드 내부이다.
  }
}
```

*위의 소스 코드의 타입이 아닌 코드들은? (if, for...)*

> 실행컨텍스트를 만들지 않는다. 렉시컬 환경만 만든다.



전역 코드 :
전역 변수를 관리한다.
전역 스코프를 만든다. -> 전역 코드가 전역 스코프르 만든다.
전역 객체랑 연결 : 전역 변수, 함수를 선언하면 전역 객체의 프로퍼티가 되기때문에

```javascript
let a = 1;
a = 2;
```

스코프는 물리적인 객체형태로 만들어진다.
위의 예제는 전역 실행컨텍스트의 렉시컬스코프의 선언적 환경 레코드 객체이다.

```javascript
let x = 1;
var x = 10;
// error 
// 선언적 환경 레코드와 글로벌 오브젝트의 식별자는 중복할 수 없다.
```

코드가 실행할 당시에 실행중인 실행컨텍스트부터 찾는다.



함수 코드 :
지역 변수가 등록되어진다.
매개변수등록(함수내부에서 선언한 var키워드의 지역변수라 생각하자.)
Arguments 객체

코드 평가? :
(표현식이 평가되면? 값이 생성되거나 값이 참조된다. 그럴때 평가라는 단어를 사용했음)
ECMAScript에서 평가라고 함

> 전역 코드가 무엇을 만드나? 실행 컨텍스트라는 객체 실체를 만든다. 그래서 평가를 한다 이해했다.
> 객체가 만들어지잖아? 전역코드가 평가가 되면?  



소스 코드의 평가 : 선언문만을 먼저 실행한다.
선언문은 반드시 식별자를 만든다. 그 식별자가 실행 컨텍스트에 등록이 되어야 한다.
평가단계에서 선언, 걔내가 등록되어야 할 실행 컨텍스트가 만들어져야한다.

**= 소스 코드가 평가되면 실행 컨텍스트가 만들어진다.**

다른언어는 main함수가 실행되어야 (진입점이있어야) 전역이 실행되지만
자바스크립트는 전역코드는 로드되자마자 평가된다.

모든 코드는 평가부터한다. 왜? 
평가를 하는건 식별자를 등록하려고 평가를한다.

평가를 하면 실행 컨텍스트가 만들어지고, 식별자가 등록한다. (호이스팅과 연결되어있다.)

> 런타임 이전에 선언문을 실행했다 ->
> 소스코드를 평가했다.



소스코드를 평가하면 실행컨텍스트가 만들어지고
그다음에 소스코드의 실행(런타임, 선언문 빼고 문을 실행)

(실행이되려면 실행컨텍스트가 있다는 전제하에서)
코드를 실행하기 위한 정보를 실행 컨텍스트에서 취득한다.

```js
x = 1;
// x를 찾아야되. 실행컨텍스트에서
/*
	실행컨텍스트에서 실행에 필요한 정보를 제공한다.
	실행결과는 실행 컨텍스트에 등록된다.
	
	자바스크립트코드가 실행되면 모든 코드 결과가 실행 컨텍스트에서 관리되어진다.
*/
```



실행컨텍스트 -> 스코프 -> 식별자 이렇게 관련있다.
*식별자와 스코프

```javascript
var x;
x = 1;
```

로드되고 바로실행하는게아니라
로드되고 평가를 하고 실행한다.

1. 실행컨텍스트를 만든다.
2. 선언문을 실행한다.
3. 식별자가 만들어지고 키로 등록되(v8엔진은 c++로 만들어진 객체이므로 자바스크립트 객체가 아니다. 통상 키라고 말하겠음)
4. undefined로 초기화된다.

= 호이스팅 원리

스코프라 말할 수 있는 실행컨텍스트가 만들어지고 등록되었다.

코드 평가가 끝나고 실행(런타임) 

5. `x = 1;` 을 보고 선언했는지 찾으러 간다.

   현재 실행중인 실행컨텍스트, 맨 꼭대기에서 찾는다.

   전역 실행 컨텍스트는 전역객체랑 연결되어있어야한다.



## 실행 컨텍스트의 역할

```javascript
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메소드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메소드 호출
console.log(x + y); // 3
```

```javascript
// 전역 코드
// 전역 컨텍스트의 렉시컬환경의 선언적 레코드
const x = 1;
const y = 2;

function foo(a) {

}
foo(100);
console.log(x + y); 

// 선언문 3개 -> 실행컨텍스트에 등록


```

모든 소스코드는 2단계를 거친다. 
실행 / 평가

```javascript
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 함수 실행컨텍스트 실행
	// 선언문 3개 : a : undefined, x, y
  // 실행 첫번째 인수가 넘어감
  // 런타임
  // var a = 100;
  const x = 10;
  const y = 20;

  // 메소드 호출
  // console을 찾는다. : 식별자 : 식별자는 어디서 찾지? 함수 실행컨텍스트에서 없으니 상위 스코프에서 찾아야되
	/*
		이 코드가 실행되기 전에 상위 스코프가 연결 되어있어야 되.
		함수는 정의된 위치에서 상위스코프가 결정되는데 그게 렉시컬 스코프인데.
		함수객체가 태어나면 자신의 함수정의가 위치한 지역에 (전역) 실행  컨텍스트의 렉시컬 환경을
		내부슬롯으로 렉시컬 환경으로 가서 찾는다.
		= 태어날때부터 상위스코프를 알고있다.
		
		console은 전역객체에 있다. 
		.log는 어떻게 평가해? -> prototype 체인에서 찾아야되. console의 프로토타입 체인에서
		()안에 값을 평가하고 호출되고 인수를 넘겨준다.
	*/

  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메소드 호출
console.log(x + y); // 3

/*
	호출 후 함수 내부를 실행 후 다시 돌아갈 곳을 안다. 
	어떻게?
	가기전에 적어논다.
	돌아갈댄 그곳으로 돌아감
	
	가기전에 line위치를 써놓는다.
*/
```



## 실행 컨텍스트 스택

자료구조 : 배열, 스택, 큐

스택은 후입선출, 나중에들어간게 먼저나와.
스택에 맨마지막에 push한것이 나중에 빼오게 된다.(pop) 
큐 : 선입선출

실행컨텍스트는 하나의 큰 객체로 이해하자.

```javascript
const x = 1;

function foo () {
  const y = 2;

  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

함수가 종료되면 실행 컨텍스트에서 pop된다. 
= 함수의 코드의 실행이 종료되었다.

push 되었다 
= 평가되기 시작하였다. 

비동기를 다룰때 테스트큐, 콜스택 ... 
이땐 콜스택이라 부름 (콜되면 스택에 쌓인다. = 실행 컨텍스트 스택)

*? 왜 위와같은 자료구조로 관리할까?*

> console.log를 찾을때 현재 실행중인 실행컨텍스트에서 찾는다.
> 실행컨텍스트가 pop되면 현재 실행중인 실행컨텍스트가 관리될 수 있다.
>
> 관리측면, 식별자를 찾는 측면에서 필요하다.



렉시컬 환경, 스코프

**환경레코드**는 스코프를 나타내는 객체(식별자 관리, 외부 렉시컬 환경에대한 참조도 가지고 있어야 한다.)

실행컨텍스트에 컴포넌트(프로포티 개념) 2개 (자바스크립트가 만든 객체가 아니라서 컴포넌트 개념을 사용, c++)
실행컨텍스트는 렉시컬 환경을 가리키고 있는것이다.

렉시컬환경을 2개의 프로퍼티

- 환경 레코드(식별자를 관리하고있는)
- 외부 렉시컬 환경 참조



```javascript
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;

  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
}
  bar(10);
}

foo(20); // 42
```

1. 브라우저를 키면 전역객체(window)만들어짐

2. Window 프로퍼티에 대한 값을 할당하기 위해 프로퍼티를 가리키고있는 객체를 생성
   그 안에는 표준빌트인 객체 / 호스트 객체 / 사용자 정의 객체

3. 전역 코드에 대한 평가
   전역객체와 빌트인객체가 있는 상태이다.
   (String같은 생성자 함수도 있을꺼고 그러면 String.prototype과 그 안에 메소드도 싹 다 만들어짐... = 할일이 많아진다.)

4. 전역코드 평가단계
   선언문들을 실행하기 위해 전역 실행 컨텍스트를 만든다. (현재 빈 객체상태)
   실행 컨텍스트 스택에 쌓는다. (전역 코드보다 먼저 실행되는 코드는 없어 항상 맨 밑애 깔려있다 = 가장 오래 살아있는 아이)

   **현재 실행중인 실행컨텍스트는 전역 실행 컨텍스트이다.**

5. 전역 렉시컬 환경을 만들며 프로퍼티 2개를 바인딩 한다.
   환경 레코드 / 외부 렉시컬 환경에 대한 참조
   환경 레코드에도 프로퍼티가 2개

   - 객체 환경 레코드
   - 선언적 환경 레코드


   바인딩 오브젝트 -> 브라우저환경 : window / node.js환경 : global을 가리킴

> ES5에서는 무조건 Object Environment Recode(window참조 가능)로 갔음
> Declartive Environment Recode(선언적 환경레코드, window의 프로퍼티가 아니다.)가 없었다.

함수 이름으로 식별자를 암묵적으로 자바스크립트 엔진이 만들어주는데
Object Environment Recode로 간다. (전역 객체의 메소드로 들어간다.)

const는 선언과 동시에 할당문까지 동시에 써줘야한다.
할당을 했는데 `<uninitialized>`라는 값이 들어옴.

할당문은 런타임에 들어와야한다.
원래같으면 undefined가 들어가야하지만(변수 호이스팅이 일어난다.)
const는 값은 채우긴 하지만 그 값이 들어와있을때(뭔진모르지만) 에러를 뱉는다 = TDZ // 할당문이 실행할때까지
let은 변수선언문에 도달할때까지 TDZ

this값은 GlobalEnvironmentRecord에서 가진다.
[[thisValue]]
this가 결정되는 방식에따라 this가 반환된다.

// 코드 실행 전 상황이다. (코드 실행의 준비)

**위가 진행되면 전역코드의 실행단계로 넘어간다.**

실행컨텍스트가 만들어지면 렉시컬환경이 만들어진다.

전역 렉시컬 환경 

- 환경 레코드
- 외부 렉시컬 환경 참조

전역 환경레코드는

- 객체 환경 레코드
- 선언 환경 레코드

함수는 1개로 이루어져있음

- 함수 환경 레코드
  매개변수, arguments, 지역변수, 중첩함수가있으면 중첩함수까지 관리



함수가 태어날때 정의된 위치가 상위스코프이다.
-> 어디서 호출될 지 모르기때문에 어디서 호출되더라도 



함수 자체에 내부슬롯을 가지고 있음 [[environment]] -> 상위스코프의 참조를 가짐
즉 함수가 위치한 전역 렉시컬환경의 참조를 가지고있다.

함수가 정의가 평가되어져서 함수객체로 만들어 질때,
자신의 상위스코프를 결정한다.
= 랙시컬 스코프 (함수가 자신의 상위스코프를 결정하는 방법을 위와같이 푼것이다.)

---

window 객체는 이름이있다. 이 이름으로 참조하고
window 객체는 어플리케이션과 생명주기랑 같다.

if문은 실행컨텍스트를 만들지는 않지만 스코프는 만든다.
스코프 = 렉시컬

---

## 클로저

함수가 선언된 렉시컬 환경

> 렉시컬 환경 = 스코프
> = 함수가 정의된 위치의 스코프
> = 상위스코프
> = 모든함수는 클로저다 왜? 모든 함수는 자신이 선언된 렉시컬환경과 연관되어있기때문에
> 	하지만 일반적인 함수를 클로저라고 하지는 않는다.



함수 객체가 평가될 때 함수객체의 위치가 곧 상위스코프이다.

실행컨텍스트의 관점에서는? (이부분!)
함수가 평가되어서 함수객체가 만들어지는 시점에 실행중인 실행컨텍스트의 렉시컬환경이 함수객체의 상위스코프이다.
(내부슬롯 environment에 참조한 값)

bar 호출될때
bar 실행컨텍스트생성, bar 렉시컬환경

```javascript
const x = 1;

// ①
function outer() {
  const x = 10;
  const inner = function () { console.log(x); }; // ② 실행컨텍스트만 죽는것
  return inner;
}

// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.
// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다.
const innerFunc = outer(); // ③
innerFunc(); // ④ 10

```

함수가 함수를 리턴한다 : 고차함수

`const innerFunc = outer(); // ③`
함수객체로 평가되기때문에 호출할 수 있다.

실행 컨텍스트에서 pop되는건 스택에서
inner function object의 [[environment]]로 outer lexical environment로 참조하고있다.
함수가 종료되었을때,  바로 호출되는데 (inner실행)

// 외부함수보다 내부함수가 더 오래 살아있다.

통상적으로 클로저는 아래 2가지를 만족해야한다.

- 외부함수, 내부함수가 있는 상황 외부함수보다 중첩함수가 더 오래 살아남아야한다. 
  (대부분 중첩함수를 return하는 경우)

- 중첩함수가 외부함수의 식별자를 참조한다.

  

foo함수가 종료되어있어도 그안의 bar함수가 return되었고
그 bar 함수가 상위렉시컬환경을 바라보기때문에 

bar함수가 기억하는 상위스코프에대한 참조



## 클로저의 활용

상태를 안전하게 유지할 때 사용한다.

> 기존에 바뀔 수 있어서 재할당이 가능한 상황인데 안전하게 유지하고싶다.



```html
<!DOCTYPE html>
<html>
<body>
  <button class="increase">+</button>
  <span class="counter">0</span>

  <script>
    const $counter = document.querySelector('.counter');

    // 버튼이 클릭되면 자유 변수 num을 1 증가 시킨다.
   	// 함수 리턴 -> 함수객체를 생성해서 리턴
    /*
    이 함수객체를 increase가 보고있다.
    */
    const increase = (function () {
      // 카운트 상태를 유지하기 위한 자유 변수
      let num = 0; // return function만 이 변수를 볼 수 있다.
			
      // 랙시컬 환경의 외부환경 참조를 따라가면 살아있다.
      return function () {
        $counter.textContent = ++num; // 상태 변경
      };
    }());

    document.querySelector('.increase').onclick = increase;
  </script>
</body>
</html>
```

// 위 코드는 외우자

1. 즉시실행함수를 만든다
2. 그 안에 유지시킬 변수를 선언한다.
3. 그 변수의 상태를 변경시킬 함수를 만들어 리턴한다.