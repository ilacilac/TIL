```javascript
var x = 5, result;
// var x = 5;
// var result;

// 선할당 후증가 (postfix increment operator)
// var x = 5;
// var result;
result = x++;
console.log(result, x); // 5 6


```

널은 해제할때쓰지만 해제를 안해도된다 = 스코프를 좁힌다.



# 데이터 타입

- 언어의 종류에 따라 데이터 타입이 다르다.

  ```javascript
  int x; // 타입지정, 선언 -> 정적언어
  // 언제나 int타입이야
  var x; // 선언 -> 동적언어
  // 타입을 예측 할 수 없다. 
  ```

  정적언어는 내가 사용하려는 목적이 뚜렷하다.

  자바스크립트도 마찬가지이지만 돌려써도 되라는 의미가 담겨있다.

  >  할당을 할 수록 데이터 타입이 바뀔 확률이 높아진다.

  

`undefined + 1` :  NaN값 반환

추측을해서 `1 + x` 를 했는데 중간에 타입이 바껴서 위와같이 엉뚱한 값을 반환할 수 있기때문에 **변수를 사용할 때 타입을 확인해야할 수 있다.**



## 원시타입

1. 숫자

2. 문자열 : 0개이상의 문자

   `''` : 빈문자열 (문자가 0개)

   > 문자가 1개 10개.. 다 다르다.
   >
   > c언어 같은건 'abc' 를 값이 여러개로 취급 'abc' = a / b / c 
   > 하나의 값으로 취급을 못한다
   >
   > 근데 왜 자바스크립트는 하나의 값으로 취급할까?
   >
   > - 언어취급하기 까다로워 그렇게 설계되었다
   >   자바스크립트의 좋은점

   자바스크립트 관점에서 `a` 는 식별자이다.

   ```javascript
   'a'
   "a"
   `a`
   
   // 문자리터럴, 값을 만드는 방법
   
   new String(); // 함수를 통해서 만들수있지만.. 뻘짓
   ```

3. 불리언

   ```javascript
   // true, false
   // 따옴표안붙여주면 식별자라매! > 이건 예약어야
   ```

4. undefined 

   ```javascript
   // undefined는 리터럴로 만들 수 있지만
   // 만들일이 없고 만들어서는 안된다.
   ```

5. null

   ```javascript
   // 값이 없을 나타내는 값
   // 변수는 쓰레기 값이라도 갖고있다. 근데 없는걸 표현하고싶을때 쓴다. (나중에 다시 설명)
   ```

   

기본적으로 값을만든다라는 것은
= 리터럴 (1)
= 표현식 (1 + 1)



## 객체타입

> *왜 원시타입과 객테차입을 나눠놨어?*
>
> **성격이 다르기 때문에**



```javascript
// 어떤기준을 가지고 정해야되
1과 '1'

1은 숫자를 사용 : 계산하기 위해
'1'은 문자 : 기록, 읽히기 위함 = 출력하기 위함(웹페이지 ...)

'1' // 유니코드로 변환되어 메모리 할당
1 // 2진수로 변환되어 메모리에 할당

// 참조할때는
'1' // 유니코드를 변환해서 가져와야되
1 // 2진수는 10진수

// 그 기준이 데이터 타입
/*
	1. 숫자를보고 -> 숫자타입이구나 -> 8바이트 
      주소가 8개
      식별자로 지정되면
      선두 어드레스를알고 바이트수를 알면 꺼내올 단위를 알 수 있다
      중간이면? 계산하기 복잡하잖아.
  한문자는 2바이트 
  ('1'은 몇바이트인지 정확히 몰라 그 이상의 정보가 없어서 
	몰라 최소 2바이트이겠지)
	
	2. 뭐로 해석할지
	 	 데이터 타입을 알아야 해석할 수 있다
	3.
*/
```



### 숫자

- 배정밀도 64비트 부동소수점 형식

  10이라고 정수라고 써도 사실상 10.0

  정수도 실수라 처리한다.

  `10.0 === 10; // true`

  3.141592 -> 3141592 * 10^-6

  양수 음수 구분하는 1비트를 사용하고 11(10^-6) 52(3141592)

  배정밀도 : 64비트 // 더 큰수를 넣을 수 있다

  정밀도 : 32비트

  // 컴공은 이런걸 집요하게 공부해

- 정수를 정수로 나눠도 실수가 나온다.

  3/ 2 = 1.5

  = 3.0/2.0 = 1.5

- 리터럴로 추가적으로 3가지 특별한값을 표현할 수 있다

  - Infinity

  - -Infinity

  - NaN

    'x' * 10



## 템플릿 리터럴

1. 멀티라인(개행할때)

   \n : LF(Line feed) 

   CRLF이 되어있어서 vscode 하단에 빨간경고

   타자기로 개행할 때 톡 돌리면 종이가 말려있던게 한줄이 똑 가(새줄이 가) 그게 라인피드

   \r : (carriage return)

   두들기고 있던 커서를맨 처음으로 댕겨주는게 캐리지 리턴

   

2. 표현식

   숫자 + 숫자 // + : 산술연산자

   문자 + 숫자 // + : 문자열 연결

   > ```
   > `${}`
   > ```
   >
   > 위 안엔 어떤 타입이 들어있는 값이 들어와야되?
   >
   > 모든값이 문자열로 변환이 되? -> 그렇진 않아



## 불리언 타입

조건문에서 자주 사용



## undefined

우리가 만들일 이 없어

자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.



## null

null은 null이 유일하다.

없는 노드를 셀렉트를 잡았을때 Null값이 반환된다.

빨리 해제시켜 주고싶을땐 변수 자체를 없애야돼

- scope를 좁힌다.

null을 직접적으로 할당할 일은 없을것이다.



함수는 문들의 집합을 여러번(재사용)하고 싶을 때 사용한다.
변수 역시 동일

함수는 결과값을 내뱉는다. output을 반환할때 



- 값은 메모리에 들어가기전에 데이터타입을 통해 메모리에 들어간다
- 읽어들일때도 몇 바이트를 읽어드려야하는지도필요하고 그때 필요하고
- 불러드린 2진수를 해석해야하는데 그때도 어떤식으로 해석해야하는지의 지침이 데이터 타입



## 동적 타이핑

타입을 만든다의 의미의 타이핑

타입이 변한다

타입에 상관없이 값을 넣을수 있으니 좋은걸까?

> 편리는 하지만 부작용이 있다.
>
> - 타입을 알기 어렵다
>
>   (변수를 많이 쓰지 말라는 이유와 동일)



상태의 변화 때문에 값이 재할당된다.

타입추론 : 할당되어진 값에 의해서 타입을 추론한다



변수를 사용할 때 주의해야한다.

- 필요할때만 사용 할 것

  코딩을하다보면 선언해서 썼는데 필요가 없어졌는데 그 로직만지우고 변수선언은 지우지 않은경우가 많다. 그게 지속되면 쓸대없는 변수가 많아진다 -> 방지하기위에 ESLint를 사용

  스코프가 작으려면 함수가 작아야하고
  함수가 작으려면 하나의일만 해야하고

- 전역변수를 가급적 사용하지 않는다

- 상수를 지향하자 (재할당을 가급적 하지 말자)

- 네이밍을 목적에 맞게 신경써서 해주자

  > 코드는 문서이기때문에 커뮤니케이션이 안되면 협업이안된다.



리팩토링

> 일주일전 나와 대화



가독성이 좋은 코드를 써야한다 퍼포먼스는 나중문제

> 예쁘게
>
> ESLint 가 잡아줄것!





## 연산자

++증가가 됬다 암묵적으로 재할당된다.
**= 부수효과가 있는 연산자**

연산자중에 딱 두개있어 : --와 ++

for문(반복문)에서 많이 사용함

```javascript
// = 기준으로 먼저 계산하느냐 안하느냐야
var x = 2;

// 변수에 증가/감소 연산자 값을 할당되는순간에 차이점을 느낄 수 있다.
// 단순히 피연산자에 선할당,후증가이나 선증가,후할당을 하게될때는 최종 증가된값으로 나오므로 차이점이 안느껴진다.
for(var i = 0; i < 10; i++){
    console.log('coding everybody' + i + '<br />');
}
for(var i = 0; i < 10; ++i){
    console.log('coding everybody' + i + '<br />');
}
```

```javascript
for (var i = 0; i < 5; ++i) {
    var result = ++i;
    console.log('result',result);
    console.log('i',i)
}
// result 1
// i 1
// result 3
// i 3
// result 5
// i 5
```

```javascript
for (var i = 0; i < 5; ++i) {
    var result = i++;
    console.log('result',result);
    console.log('i',i)
}
// result 0
// i 1
// result 2
// i 3
// result 4
// i 5
```



```javascript
+'10'; // 10

var x = '10';
var y = +x;

1. 메모리에 '10'할당
	값이 만들어져야 +를 하기때문에
2. 숫자가 안나오는 문맥이다 -> 에러일까? 판단.. -> 숫자로 바꾼다
-> 새로운 메모리 10
-> 원시값으로 변경불가능 하기때문에 ('10'에서 10으로)

// x에 부수효과가 없다(값이 안바뀐다는 의미는 덮어쓴다는 의미이기때문에, 메모리에 새로 숫자를 바탕으로 만드는것)
 
```



왜 0은 false일까?

1은 전기신호가 있다 = 값이 있다 , 0은 없어서 false



+는 문자연결 / 산술연산 2가지할 수 있다.



피연산자가 둘다 넘버 : 산술연산으로 동작
피연산자가 하나 이상 문자열 : 문자열 연결 연산

```javascript
'1' + false // "1false"
```



`1 + undefined; // NaN`

만약 undefined가 0을 반환한다면

`var x;`

`x + 1 = 1;` 의 공식이 성립되므로 0을 반환하면 곤란한 일이 생긴다.



할당연산자는 표현식인 문이다 = 할당되어진 값으로 평가된다

```javascript
5 == 5;
// 주소는 다르다
// 값 자체를 비교한것

5 == '5'; 
// 타입을 일치시킬 수 있으면 일치시켜서 값을 비교한다.
```



NaN === NaN; // false // 이상한현상..

정확히 판별하고싶으면 isNaN() 을 사용한다.

es6에서 개선이 그래도 잘 되었어



```javascript
var x = 1;
var result = '';

// 이렇게 하면안되
/*
 1. result 중복 
 2. === 0 을빼도됨
*/
if (x % 2 === 0) {
	result = '짝수';
} else {
  result = '홀수';
}

// 이렇게쓴다
if (x % 2) {
  result = '홀수';
} else {
  result = '짝수';
}
// if 코드블럭은 표현식이 아닌문이야
// 삼항조건연산문은 if else연산문을 대체할 수 있다
// ㅁ ? ㅁ : ㅁ;

var result = x % 2 ? '홀수' : '짝수';

// 1. 일단 if문을 쓰고
// 2. 삼항조건연산문을 사용한다.
// 3. 1보다 2가 길어지면 1로 돌아간다.
```



단축평가

'' // false

'Cat' && 'Dog'; // true는 둘다 맞아야되니깐 마지막걸로 평가된다 -> 'Dog'



typeof null; // object

함부로 표준을 바꾸면 문제가 될 수 있기때문에 못바꿈
`===` 으로 비교해보자



### 지수 연산자

-5 ** 2; // 오류 ->

(-5) ** 2;

ES6에서는 error을 적극적으로 뱉어낸다.

2 * 5 ** 2; // ** 가 더 우선순위가 높다.



### 부수 효과

- ++/--(증가/감소 연산자), 할당연산자, delete 연산자



---

**8,9 : 예습해오기**

