# 200522

```javascript
const result = [1, 2, 3].forEach(console.log); // 콜백함수가 올 자리
/*
무조건 호출하면 v, i, arr가 호출됨
= forEach((v, i, arr) => console.log);
= 가변인자함수 
*/
// 1 0 [ 1, 2, 3 ]
// 2 1 [ 1, 2, 3 ]
// 3 2 [ 1, 2, 3 ]
console.log(result);
// undefined
```

```javascript
class Person {
  sayHi = () => {}; // 7번줄 이후에 만들어짐
	/*
	constructor() {
		// 인스턴스 생성되고 프로퍼티 동적추가되서 생성됨
		this.sayHi = () => {};
	}
	*/
	sayHi() {} // 런타임이전에 만들어짐
}
new Person(); // 인스턴스 만들어짐

// 인스턴스가 만들때 들어감
// 클래스정의가 평가되면 생성자함수가 만들어짐 -> 프로토타입객체와 쌍으로만들어짐
```



```javascript
// Q1) numbers 배열의 요소를 내림차순으로 정렬해주세요.
const numbers = [8, 10, 2, 5, 198, 33, 2934, 11, 230, 64, 923];
*키워드 : sort, 비교함수
console.log('Q1');
console.log(numbers); // [ 2934, 923, 230, 198, 64, 33, 11, 10, 8, 5, 2];
// Q2) words 배열의 각 요소(문자열)를 역순으로 가지는 새로운 배열(newWords)을 만들어주세요.
const words = ['hello', 'world', 'nice', 'to', 'meet', 'you'];
// const newWords = ??
console.log('Q2');
console.log(newWords); // [ 'olleh', 'dlrow', 'ecin', 'ot', 'teem', 'uoy' ]
*키워드 : map, 문자열을 뒤집어서 리턴 
// Q3) numbers2 배열의 요소 중 5의 배수만을 포함하는 새로운 배열(multiples)을 만들어주세요.
const numbers2 = [43, 18, 10, 99, 35, 80, 5, 111, 120];
// const multiples = ??
console.log('Q3');
console.log(multiples); // [ 10, 35, 80, 5, 120 ]
*키워드 : filter 조건 -> 콜백함수 바디는 불리언을 반환 = 조건식을 만들어줘야함
// Q4) numbers3 배열의 요소 중 요소의 값이 인덱스와 일치하는 요소를 출력해주세요.
const numbers3 = [0, 3, 88, 3, 2, 4, 6, 8, 8];
console.log('Q4');
// ??
// 0
// 3
// 6
// 8
*키워드 : forEach, 출력하라니깐, 순회하면서 현재 i랑 indexOf비교해서 맞는거만 콘솔찍기
// Q5) kvArray 배열을 사용하여 아래 예제와 같은 요소를 가진 새로운 배열(reformattedArray)을 만들어주세요.
const kvArray = [
  { key: 1, value: 10 },
  { key: 2, value: 20 },
  { key: 3, value: 30 }
];
// const reformattedArray = ??
console.log('Q5');
console.log(reformattedArray);
/*
[
  { '1': 10 },
  { '2': 20 },
  { '3': 30 }
]
*/
*키워드 : 유사배열만들기, map, key로 접근한 값을 새로운 리턴값으 ㅣ키로, 밸류의 프로퍼티값을 새롭개만든 객체의 값 return
```

---



## 정규표현식

정규표현식이라는 문법이 따로 있음.
펄(Perl)의 정규표현식을 따름

`ctrl + f` 찾기기능

> for문 한글자씩 보고 맞으면 그 다음글자....
> 쉽지 않다.
>
> 정규표현식이면 한줄이면 된다.



```javascript
^ : 어떤문자열의 맨 앞
$ : 어떤문자열의 맨 끝
d : 숫자(정수)
{3} : 3개

패턴 : 문자열이 패턴과 일치하는지 검사

// 정규표현식 리터럴
// 휴대폰 전화번호 패턴(숫자 3개 + '-' + 숫자 4개 + '-' + 숫자 4개)
const regExp = /^\d{3}-\d{4}-\d{4}$/;
// /^\d{3}-\d{4}-\d{4}$/ : 정규표현식 리터럴
// regExp : 객체
맨앞이 정수이고 3개 연속되고, -(문자열) 그다음 정수가 4글자 오고 -(문자열) 정수가오고 4개인데 마지막에옴

// 돔에서 가져온 문자열과 패턴이랑 일치하는지 테스트 
// tel이 휴대폰 전화번호 패턴에 매칭하는지 테스트(확인)한다.
regExp.test(tel); // -> false

// 정규표현식 객체의 프로토타입 메소드 test() 
// 문자열이 정규표현식 패턴에 통과하는지 = 불리언 리턴

/패턴/플래그
*플래그 i : 대상문자열에서 패턴이 있는지 없는지 검사하는데 대소문자 구별하지 않고 검색한다.(만약 띄면 구별하여 검색)
					여러개 있을때 한개만 찾음
*플래그 g : 처음부터 끝까지 다 찾음 
플래그 m : 멀티라인, 개행이있어도 다 보겠다.
```

---

## spread 문법

,로 구분되어져있는 값들의 목록으로 이루어진 자료구조를 푼다. => 배열, 객체
이게 연산자라면 값이되어야한다.
값이 올 수 있는자리에 사용못함.

**= 연산자가 아닌 문법이다.**

이터러블 

> 스프레드 대상, for...of문 순회가능

- 배열
- argument객체
- nodeList
- HTMLCollection
- Map, Set

**일반객체는 이터러블이 아니다.**
하지만 새로운 제안이 나왔다. => 프로퍼티도 풀 수 있는 문법

**Rest파라미터랑 해깔리지말것.**
Rest파라미터는 인수들을 배열로 모은다.

```javascript
// ES5
var arr1 = [1, 4];
var arr2 = [2, 3];

// apply 메서드의 2번째 인수는 배열이다. 이것은 인수 목록으로 splice 메서드에 전달된다.
// [1, 0].concat(arr2) → [1, 0, 2, 3]
// arr1.splice(1, 0, 2, 3) → arr1[1]부터 0개의 요소를 제거하고
// 그자리(arr1[1])에 새로운 요소(2, 3)를 삽입한다.
Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));
// apply는 Array.prototype.splice를 호출한다.
// 그럼 인수를 어떻게 전달해줘? apply에 인수로 준다.
// call은 배열로 받는다.
// apply는 요소로 받는다.
// arr1 : this
// splice에서 풀어서 넘어간다.
console.log(arr1); // [1, 2, 3, 4]
```

```javascript
console.log('7번 문제');

/*
  모든 요소의 completed 프로퍼티 값을 true로 설정
*/
let todos = [
  { id: 3, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: false }
];

function toggleCompletedAll() {
  // todos.map(todo => ({ ...todo, completed: true })); // 함수몸체인지 리턴인지 해깔리니깐 ()로 묶어줌
  todos.map(todo => Object.assign({}, todo, { completed: true })); 
}
// 1. 빈객체만든다
// 2. 덮어쓴다
// 3. 프로퍼티를 덮어쓰도록 한다.
toggleCompletedAll();

console.log(todos);
/*
[
  { id: 3, content: 'HTML', completed: true },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'Javascript', completed: true }
]
*/
```

---



브라우저 : 렌더링한다.

html : 구조와 정보

`<button></button>` : 컨텐츠가 올 수 있음
Input type="button"

초기값은 어트리뷰트에서
상태관리는 프로퍼티에서 관리한다.

> Ex) input의 checked

노드에 접근할 줄 알아야 된다.
접근하기 위한 함수가 필요함 : DOM API

API는 함수들이라고 생각하면된다.

렌더링과정이 시뮬레이션이 되어야 한다.

1. url입력한다.

2. 렌더링하려면 재료가 있어야 한다. (재료 = 리소스)
   리소스는 서버에 있다.
   ex) 네이버를 입력하면 네이버서버에 감

3. 찾아가려면 : 물리적인서버에 가야함
   인터넷으로 통신을 하니 인터넷에 물려있어야함
   어떻게? => 주소를 알아야 한다. => 유니크해야함 => 컴퓨터마다 유니크한 주소가 있어야 한다.(인터넷과 물려있는 고유의 LAN카드 = **IP주소**)
   IP주소를 사람이 알기 쉽게 식별자를 줌 = **도메인**

   www.naver.com를 치는순간 이 식별자가 도메인이 

   1. IP랑 바꿔치기 (결국 IP로 찾아가는것)

   2. 도메인과 매핑테이블을 관리하는걸 DNS서버라고함

   3. 도메인을 주고 IP주소를 받아서 서버로 간다.

   4. 리소스를 달라고 요청 = request
      request : html / css / js / (font / images)

   5. client : 요청 / server : 응답(response)
      단방향 통신

      > 우리가 핸드폰으로 전화할때 서로 말할 수 있음 
      > 무전기로하면 내가 얘기하고 상대방이 얘기하고 한번 한번 (단방향)
      >
      > 요청한다(끝) / 응답한다(끝)
      > 하나하나하나하나
      >
      > 응답을했는데 요청이 안온다? 
      >
      > - 잘못갔을 경우(404오류)
      >
      > 달라고하는 정보는 없잖아? 근데 잘나오잖아 뭐 달라고 하지않았는데?
      >
      > - 도메인 뒤에 /index.html이 생략되어있다.
      >
      > - 도메인만 있는 상태를 루트요청한다라고 한다.
      >   요청이 /
      >   루트요청을 주면 기본으로 index.html을 주도록 설정되어있다.
      >
      > - 받아오고 응답선에 되돌린다
      >   어디서 요청이들어왔는지 알아야한다. (내주소가 이건데 ip 뭐를 주세요)
      >   서버가 받아서 index.html을 줘야한다.
      >   index.html이란 파일을 찾는다. => 서버의 파일들을 모아놓는 공간이 있다.
      >   그 공간에 상위 : 루트폴더 = 서버도 컴퓨터, 어느 폴더인가를 정해서 파일들을 갖다놔야한다.
      >
      >   못찾았을때 못찾았단 응답을 보내고
      >   있으면 파일을 보낸다 어떻게? => 서버가 파일을 읽는다 = 메모리상에 2진수로 불러들인다 텍스트파일을(index.html을 한자한자 읽어서 메모리상에 불러들인다.)
      >   그것을 요청한곳으로 보내야되는데, 잘라서 보낸다 = **패킷** 
      >
      >   랜선을 타고(인터넷), 0100101같은이진수가 온다.
      >   그것을 브라우저가 받는다. => 메모리상에 받아들인다.
      >   패킷이 몇개인지 알려줌. 그래서 하나로 모아서 합쳐, 문자로 바꾼다**(다운로드)**
      >   01010된게 서버에 html된 상태를 만든다.
      >   01010을 해석하려면 무슨정보가 있어야되? =? 000110이 어떤 포맷인지알아야함 => characterSet
      >
      >   서버가 일어날때 이부분을 확인하고 파일포맷을 안다.

      브라우저가 해석해야한다.

      > 요소별로 쫙 쪼갠후 해석
      >
      > - html, head, link, h1 .....
      >
      > 요소별로 객체를 만든다 = **노드**
      > HTML은 **구조**가 있어야 한다.
      > => 노드와 노드가 형제, 부자관계의 자료구조를 만들어야함 
      > = 트리자료구조
      >
      > 트리자료구조는 나무가 뒤집어있는 자료구조이다.
      > 노드 하나하나는 객체이다.
      >
      > html구조는 처음부터 끝까지 html로 되어있다.
      > 그다음에 head, body형제

      head안엔 메타정보 (정보의 앞에있는것, html정보를 설명하는 데이터)
      body안엔 렌더링 대상들이 온다.

      node들이 CSS정보를 가지오있다.
      상속관계가 있다

      (그리기위한 작업)

   6. 그리기 시작 

      1. 레이아웃을 잡는다.
         요소의 위치를 계산한다.

      2. 도트를 찍는다.(페인팅)



랜더링엔진 !== 자바스크립트 엔진
렌더링엔진은 소프트웨어이다.
HTML,  CSSOM트리가 랜더트리 하나가되서 렌더링을하고 페인팅을 한다.

javaScript가 요소를 날려다?
자바사스크립트는 새로운 요소를 만들 수 있다.

어떨때 렌더링 하기 어려울까?

- 레이아웃을 바꾸는것은 다시그려야하므로 퍼포먼스에 악영향을 준다.
- 컬러만 바꾼다면? => 이건 좀 수월하다.



앞으로 DOM을 자바스크립트로 건들 껀데
브라우저가 힘들지 안힘들지 생각해보자.

할건 하되, 좋은 방법이 있는지 생각해본다.

ex) 어떠한 요소를 추가한다.

```
http 그림으로 되어있는 책 봐보면 좋다.
// 38장 다시 읽기
// 39장 공부하는 방법
- 이럴때 이함수 이럴때 이함수 / 메소드에대한설명임
- 이론을 빠삭하게 아는게 아니라 이 요소에 접근해야할때 어떻게 해야한다하고 쓰윽 읽어보고 오기. 마스터한다는건 욕심이다.
```



