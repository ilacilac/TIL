토큰을 가지고 자료구조를 갖고, 이걸가지고 삼항조건연산문인걸 알게된다.
표현식으로 나눠생각

`표현식` ? `표현식` : `표현식`;

```javascript
'1' < 0 // false
null < 0 // false
undefined < 0 // false
/*
	연산자에선 에러를 안낸다.
	그래서 false를 반환한게 아닌가 추측
*/
```

```javascript
const foo = true;
let bar = 0;
const result = foo || bar++;

// 이미 좌항에서 표현식에서 평가가 된다면 우항은 안본다

const foo = false;
let bar = 0;
const result = foo || bar++; // 이땐 0이겠지??? 0은 맞는데 메모리를 까보지 않는이상 이 순간에 0이 대입되는건 알 수 없어.
console.log(result); // 1

// ???0이야
```

if문은 그 안의 코드에 영향을 주는게 아니라 (예를들면 코드를 바꾸거나) 조건식에 따라 블록문을 실행할지 안할지만 결정해주는 역할을 한다.

표현식의 평가

코드블럭 안에 할당문이오든 어떤문이오든 상관없어
if가 관심있는건 할지 안할지가 중요해 (조건식)

if문은 문법상 표현식이 아닌 문이다. `if() {}`

```javascript
if () {
	x = 1;    
}

// if () {}와 x = 1;의 문이랑 별개야
// x = 1;이 if문의 전체평가라고 생각하면 안돼

```

if문이 표현식이 아닌이유는 

var x = 1; // 전체는 표현식의 아닌문 -> 왜? var키워드를 썻어
x = 1; // 표현식인 문

If 키워드가 있으면 표현식이 아닌문이라고 기억해두자



가변인자함수

`console.log('a', 'b');`
연이어서 표시하는데 스페이스바를 이용해서 표시

위에서 , 를찍으면 인수를 2개준거야

---



# 객체

 javaScript : 프로토타입 객체지향 언어
+명령형 / 절차지향 / 함수지향도 포함

= 다 알아야함

object(객체) <-> subject(주체)
프로그래밍언어에서 주체 -> 프로그래머

객체 : 0개 이상의 프로퍼티의 집합

프로퍼티? 아래예시에서의 프로퍼티는 관심있는 데이터임.
프로퍼티 키와 값의 쌍

```javascript
var person = {
  name: 'lee',
  age: 20
};


// 객체 리터럴 // 값을 만들어내는 표기법 // 표현식
{
  name: 'lee',
  age: 20
};

// age라는 자산이 20이다.
// 현재 person개체에 age의 상태(변한다는 전제하에 상태)
// 값이 상태를 바꿀 수 있다.

```

하나이상의 값을 그룹화 해놓은게 자료구죠

배열은 순서(index)로 값을 찾는다.

객체사용이유? 
여러개의 값을 하나의값처럼 쓰고싶어서
관련이있는것끼리 

상속 : 재사용의 관점



원시타입값 / 객체타입값

객체는 데이터뿐만아니라 행동을 나타내는 함수도 갖는다.
= 메소드
메소드의 프로퍼티키 : 이름 /  메소드의 프로퍼티값으로 함수 올 수 있음



자바스크립트는 클래스가 없어도 리터럴로 객체생산이 가능한 큰 장점이 있었다.
객체리터럴안에서 this는 자기자신을 나타낸다

> 자기의 프로퍼티를 참조하기 위함

this.name

문이 종결될때 `;` 을 붙인다.

```javascript
// 코드엔 문맥이있다.
{ } // 코드블럭 or 객체리터럴로 해석할 수 있다.
// 이렇게 단독으로 쓰이면 코드블록으로 인식


var o = {};
// 값이오는 문맥 = 객체
```

프로퍼티키에는 원래 문자열을 쓴다. (??비문자열 포함한 모든 문자열 / 문자열 / 심볼)
식별자 네이밍 규칙을 지키지 않아도 된다.
하지만 식별자 네이밍 규칙을 안지키면 귀찮아진다.

프로퍼티키는 ''를 생략할 수 있다.

> 왜? 내부적으로는 문자열키로 가지고 있어.
> 식별자 네이밍 규칙에 안맞는건 꼭 써야되

프로퍼티 값에는 자바스크립트에서 사용할 수 있는 모든 값이 올 수 있음.



```javascript
// 유사배열객체
// 숫자가 프로퍼티키에 올 수 있음
// 메소드도 프로퍼티야
```

```javascript
var person = {
  name: 'Lee'
};

console.log(person.name); // Lee 
```

.은 연산자라 좌항 우항이있어 좌우를 띄면안돼
마침표연산지, 프로퍼티연결연산자

좌항 : 객체 / 우항 : 프로퍼티키

객체에 존재하지않은 프로퍼티키로 접근하면 결과가 undefined가 나온다

`console.log(person['name']);`

[] 표기법을 쓸때 왼쪽에 객체 그안엔 표현식 -> 문자열로 평가되어야함

```javascript
var person = {
  address: { city: 'seoul'},
  1: 10
}
console.log(person.addres.city);
// = undefined.city // undefined에는 city가 없단 에러가뜸

console.log(person.1); 
// 안되는 이유
/* 
	문자열이 와야되는데 숫자가옴
	'1'로 바꿔주면? -> 안돼 문법상
	person[1]은? -> 돼 -> 내부적으로 문자열로 봐줌
	배열 요소에 접근하는 느낌이 든다
*/

var str = 'Hello';
console.log(str[1]); // e
// str이 객체로 보고있네? -> 객체로 변환해줌 '레포객체'
// str오는자리에 문자숫자불리언이 오면 객체로 바꿔줌
// 프로퍼티키가있을꺼네? -> yes
// 유사배열 객체

// person[1] 로 써주자

var person = {
  'last-name': 'Lee',
  1: 10
};
// person.last-name;
/*
	person.last : undefined
	name : 전역변수
*/
```

객체는 재할당없이도 값을 바꿀 수 있다 = 변경가능한 값
person.name = 'kim'; 이것이 재할당이 아니야
person = {} 이게 재할당이야

재할당을 안한다 가정해도 바뀔 가능성이 있다.
원시값이 더 안정적

**상태변경추적하기가 어려운점에 주의하자**

상태가바뀌었을때관리될 필요성이 있기때문에 리액트에서 다루게됨

객체를 원시값같이쓴다?
변경 불가능하게 -> 객체내용이 프로퍼티가 10개가있다. 바꿀일이있다면? -> 재할당을 한다(기존바뀌기전거를 카피를떠서 새로 만들어야한다) -> copy 
-> 신뢰성있다.

원시값과 객체의차이를 아는게 오늘수업의 요지

재할당없이 동적으로 프로퍼티값을 바꾼다
`person.name = 'Kim'` = 프로퍼티값의 갱신

없는 프로퍼티의 값을 할당되면, 프로퍼티가 만들어진다.

(다른언어에서 안되는 점 중 하나)



*왜 프로퍼티를 삭제하려해?*

> 필요없어서? 그럼 왜만들어?
>
> 잠시? 그럼냅두면 안되?
>
> 지우겠다는건 메모리를 조금이라도 확보한다는건데
> 그럴필요없어 delete하지마
>
> 왜안쓰는게 좋아?
> 지워졌는지 안지워졌는지도 모르니깐, 
> 굳이 지우지말고 냅둬
> 거의 쓴걸 본적이 없어

```javascript
// 값으로 평가될 수 있으니 식별자를 평가하면 1로 평가되니 올 수 있는거야 객체안의 값으로

// ES5
var x = 1, y = 2; 
var obj = {
  x: x;
  y: y;
}
// 중첩되잖아!!

// ES6
const obj { x, y }; // 많이쓰는 문법이다!
```



## 메소드 축약표현

```javascript
var o = { // 프로퍼티가 올 수 있다.
	foo: function () {} // 메소드 ES5
  foo () {} // 메소드 축약표현
}
// 주의사항
// foo

var h = {
	foo: function () {} 
	bar () {} // 진정 매소드야 // 메소드 축약표현
	// 위에 두개가내부동작이 달라
}
```

// 옛날엔 윈도우에도 네이밍을해줬다 -> 빈문자열 기본적
// 팝업예시





# 원시 값과 객체의 비교

대부분의 언어가 원시타입 / 객체타입으로 나뉜다.

원시타입은 실제값이 메모리에저장되고
객체는 참조값이 메모리에 저장된다.

원시타입의 값은 readonly(읽기전용). 쓰기가 불가능하다.
값과 변수는 분리해서 생각해야한다.

**값의 정의** 
표현식이 평가되어져서 생성되거나 참조되어 메모리에 저장되는것

// 1 자체는 값이 아니다. -> 리터럴
메모리로 불러드리려면 값을 만들어야하는데 어떤값의 근거로 줘야한다
숫자를 만들어! 하는 2진수를 만들어서 메모리에 심어놓은게! 값

**변수**
하나의 값을 메모리공간에 저장하고 그 메모리공간 자체, 공간을 가르키는 이름

변경이 불가능하다는 부분은 값에대한영역이다.
변수의 값은 변경가능해? 재할당을하면 변수의 값을 바꿀 수 있다.
값이 바꼈냐 = 사실은 아니다
새로운값을 메모리에 적재함

**변경가능한 값**
일정공간에 {}, o라는 식별자가 가르키냐? 아니다
o가 참조값을 가지는데 그 주소값으로 객체로 접근
객체는 변경가능한값 

> *어떻게?*
>
> o.x = 1; // 변경

재할당 = 주소값을 바꿈
객체는 재할당없이도 값을 바꿀 수 없다.



객체의 특징

```javascript
/*
	객체 안에 객체구조.. 몇단계까지 파고들었는지 어떻게 알아?
	계속들어가봐야되 -> 프로퍼티접근, 값이 객체면, 안에 프로퍼티를 봐서 객체인지 판별 -> 반복 
	재귀
	값이 변경될때마다 한개씩 만들게되면 퍼포먼스가 엄청 비효율적이다.
	최근컴퓨터는 메모리성능이 좋아져서 원시값이랑 같이쓰려고는 함
	deep copy
*/
```



원시값은 불변성을 갖는다.
문자열은 원시값이야(자바스크립트에서 / 다른언어에서는 아니야)

> 왜? 원시값은 어떤특징이있어?
>
> 변경불가능해 / 메모리 생성할 때 바이트수가 딱! 정해져있어.
>
> undefined는 모르지만 딱 정해져있어
> 문자열은? 문자는 한문자는 딱 정해져있어 
>
> `''` `'a'` `'abc'`
>
> a 하나가 문자
> 문자 타입이 있다.
> 문자 타입이있고 `'abc'` 는 문자열이야. 3개의 문자가 이루어진거다
> 어떤덴 배열 / 어떤댁 객체로 다루지만 
> 자바스크립트는 내부에서 어떤 복잡한일을해서
> 원시값으로 반환(독특한 특징 / 타언어에선 그럴일이 없어)
>
> var str = 'Hello';
>
> str[1] // e
>
> str[1] = 'a' // 객체 1이라는 프로퍼티로 접근, 
> = 'a' // 값의 갱신
> 객체를 만들었을때(객체는 변경가능한 값)
> 원시값이라 안바껴
>
> 직접고친게아니라 새로만든것
> str은 안바껴 -> 문자열은 원시값이야.

```javascript
// copy에 80이 할당
// score평가 
// copy에 할당

var score = 80; 
var copy = score;
console.log(score);
console.log(copy);

score = 100;

console.log(score);
console.log(copy);

// 값은 값을 바라보고있었다면 copy도 바껴야 정상이다.
// 둘은 다른값이다.

// 실행순서
1. 두개의 선언문이 먼저 실행
undefined가 들어갈만큼
score -> undefined // 화살표: 식별자가 메모리주소를 알고있어야 한다. (메모리에)
식별자로 알수있는것은? 메모리주소 
메모리주소로 갔더니, 값이 있는것
2. copy -> undefined
// 런타임 시작, 재할당이 일어남
3. 80이 새 메모리셀에 만들어지고 score이 그 메모리를 가르킴
score을 평가하다? // 80으로 평가되었다.
  

```



객체는 원시값을 만드는것보다 훨씬 어렵다.

식별자가 원래가지고있는것
1234 주소를 가서 값을 보니 걔도 주소다
{}를 찾아가려면 2번 찾아가야되

식별자는 결국 주소를 갖는다.

원시타입/객체 : 주소로 찾아갔더니 값이냐 주소값이냐 차이

선두어드레스는 안바껴 밑으로 늘어나

```
var persin = {
	name: 'Lee'
};
var copy = person; // 주소값이 건너감 
person.x = 0;

// 메모리주소가 할당됨
// 둘다 바껴
// 원시값은 메모리 많이 사용하니깐 참조해서쓰지만
// 이런상황이 발생되는걸 염두하고 사용한것
// 이런상황이 싫어서 원시값처럼 사용하려 함

// 함수 매개변수 -> 객체가 올때 문제가 있을 수 있음
```



# 함수

```javascript
// 함수 정의
// 왜 선언이 아니라 정의야?
// ecma에 정의라구해서
function add(x, y) { // 매개변수 매개하는 변수 이어준다
// 코드블록이 하나의 실행단위 : 스코프
// 매개변수의 유효범위 {}안 -> 안그러면 계속살아있어야되는데 
// 함수가 실행될 동안만 필요하다 -> return하고나서 종료됨
  return x + y;
} // 동사로 네이밍해주자

// 함수 호출
add(1, 2); // 할당문
// 매개변수인데 머와 머? 한수 밖에 있는 값과 함수 안에서 쓰는 변수를 연결해주는거야

// 함수는 정의하고 호출을 해야하는 단계가 2개가 있구나
// 인자가 아니라 인수야
// 함수 호출이 안되면 어떻게 값을 전달해줄꺼야? : 호출문이 없으면 안돼
// 호출문이 실행되야 함수가 한번동작한다.
// 여러번 반복사용 할 수 있다. = 재사용 할 수 있다.
// 정의와 호출은 쌍이다.

// 함수를 호출한다 = call한다
// 함수를 호출하면
/*
	인수가 매개변수에 순차적으로 할당된다. (변수랑 똑같애)
	input : 인수
	코드블럭
	output : return
	함수 호출부는 표현식으로 평가된다.
*/

var result = add(1, 2); // 결과값을 식별자에 담을 수 있어.

// 함수이름을 가지고 암묵적으로 식별자를 만들어주었다.
/*
	선언문은 런타임이전에 실행
	함수선언문은 런타임 이전에 실행된다.
	변수선언문은 undefined로 
	변수호이스팅
	함수는선언 함수객체까지 할당하는것까지 한 세트
	함수호이스팅이랑 변수호이스팅이랑 다르다
	정의 전에 호출할 수 있다. // 호이스팅은 부작용이다.
	
	가독성이 좋게 선언하고 호출하도록!
*/
```

화살표함수는 일반함수에서만 사용

- argument / this /new target 사용할 수 없다.
- 메소드로 사용할 수 없다.
- 화살표함수는 콜백함수로 쓴다.(많이 쓰임)



함수가 값이다.
= 인수에 함수를 준다. -> 함수의 인수로 함수를준다 -> 값이니깐 (매개)변수할당할 수 있잖아

```javascript
[1, 2, 3, 4, 5].filter(v => v % 2); 
// filter 걸러내다 : 조건필요
// 각각의 
// [1, 2, 3, 4, 5] : 요소가 5개 for문으로 돌아야함(순회) -> filter 내부적으로 for문으로 돔 -> 각각 v에 담아줌. -> 조건식으로 사용해서 결과를 담아줌 -> false만 걸러내기 때문에 
// [1, 3, 5] 만 걸러내진다.
```

