# this

## this 키워드

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는
  **자기 참조 변수**이다.
- this를 통해 **자신이 속한 객체** 또는 **자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조**할 수 있다.
- 자바스크립트의 this는 **함수가 호출되는 방식에 따라**
  this에 바인딩될 값, 즉 **this 바인딩이 동적**으로 결정된다.



객체지향 프로그래밍에서 살펴보았듯이
**객체**는 **상태(state)**를 나타내는 **프로퍼티**와 **동작(behavior)**을 나타내는 **메소드**를 하나의 논리적인 단위로 묶은 **복합적인 자료 구조**이다.

> 동작을 나타내는 메소드는 자신이 속한 객체의 상태,
> 즉 프로퍼티를 참조하고 변경할 수 있어야 한다.
>
> 이때 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면
> **먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.**



객체 리터럴 방식으로 생성한 객체의 경우,
메소드 내부에서 메소드 자신이 속한 객체를 가리키는 식별자를 
재귀적으로 참조할 수 있다.

```javascript
const circle = {
  // 프로퍼티 : 객체 고유의 상태 데이터
  radius: 5,
  // 메소드 : 상태 데이터를 참조하고 조작하는 동작
  getDiameter() {
    // 이 메소드가 자신이 속한 객체의 프로퍼티나 다른 메소드를 참조하려면
		// 자신이 속한 객체 circle 참조할 수 있어야 한다.
    return 2 * circle.radius;
  }
};
```

객체리터럴은 할당단계에서 평가된다.
= getDiameter **메소드가 호출되는 시점에는 이미 객체리터럴의 평가가 완료**되어 **객체가 생성**되었고, **식별자** circle에 **생성된 객체가 할당된 이후**이다.
따라서 메소드 내부에서 식별자 circle을 참조할 수 있다.

하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며
바람직하지도 않다. 



**[생성자 함수 방식으로 인스턴스를 생성하는 경우]**

```javascript
function Circle(radius) {
  // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
}
```

