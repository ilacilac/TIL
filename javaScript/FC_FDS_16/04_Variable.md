# 변수(Variable)

## 변수

하나의 값을 저장하기 위해 확보한 **메모리공간** 자체
또는 그 **메모리공간**을 식별하기 위해 붙인 이름이다.



*메모리?*

> - 데이터를 저장할 수 있는 메모리셀들의 집합
>
> - 메모리셀 한개 = 1byte(8bit)
>
>   (컴퓨터는 1byte단위로 저장하거나 읽어들인다.)

```javascript
10 + 20
```

위의 자바스크립트 코드 실행 시,

1. 연산자의 좌변(10), 우변(20) = 피연산자를 기억
   (메모리상 임의의 위치에 10, 20 할당)

2. 10과 20을 + 연산자로 합산(30) 
   (숫자값 30도 메모리상 임의의 위치에 30 할당)

3. 연산은 성공적으로 끝났으나, 재사용할 수 없다.

   *왜?*

   > - 재사용 하고 싶으면 30이 저장된 메모리주소에 직접적으로 접근해야되는데 시스템을 멈추게 할 수 있는 치명적인 오류를 발생시킬 수 있다.
   >   따라서, 자바스크립트는 개발자가 직접 메모리제어를 허용하지 않는다.
   > - 제어가 가능한다해도, 코드가 실행될 때마다 메모리주소는 매번달라지므로 메모리주소를 통해 직접 접근한려는 시도는 올바른 방법이 아니다.



그래서 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고
저장된 값을 읽어 들여 재사용하기 위해 변수라는 매커니즘을 제공한다.

원리 : 변수 이름은 사람을 위해 사람이 이해할 수 있는 언어로 값이 저장된 메모리 공간에 붙인 상징적인 이름이다. 
변수 이름을 통해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근하여 저장된 값을 반환해 준다.

```javascript
// 변수는 하나의 값을 저장하기 위한 수단이다.
var userId = 1;
var userName = 'Lee';

// 객체나 배열과 같은 자료 구조를 사용하면 여러개의 값을 하나로 그룹화하여 하나의 값처럼 사용할 수 있다.
var user = {
  id: 1,
  name: 'Lee'  
};

var users = [
  {
    id: 1,
    name: 'Lee'    
  }, {
    id: 2,
    name: 'Kim'    
  }
];
```

```javascript
var result = 10 + 20;
```

앞서 나왔던 재사용할 수 없었던 예제를 위와 같이 사용하게되면
result라는 고유의 이름으로 식별할 수 있게 메모리 공간에 값을 저장한다.
30(저장된값)은 변수 값이라고 한다.

- 할당(assignment) : 변수에 값을 저장하는 것
- 참조(reference) : 변수에 저장된 값을 읽어들이는 것



## 식별자

- 어떤 값을 구별하여 식별할 수 있는 고유의 이름
- 메모리의 주소를 기억하고 있음
- 메모리의 주소에 붙인 이름



## 변수 선언

- 변수를 생성하는 것을 의미

  = 메모리공간을 확보하여 변수 이름으로 메모리주소와 연결하여 값을 저장할 수 있게 준비

- 선언 시, `var` `let` `const`  키워드를 사용한다.

  *키워드?*

  > 자바스크립트 엔진이 수행할 동작을 규정하는 일종의 명령어
  >
  > ex) 자바스크립트 엔진 : var 키워드가 실행되었으니 이 뒤에오는 변수이름으로 새로운 변수를 선언해야지!
  >
  > - 선언 단계(Declaration phase) : 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
  > - 초기화 단계(Initialization phase) : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당한다.

- 선언 후 값을 할당하지 않으면 `undefined` 라는 값이 암묵적으로 할당되어 초기화 된다.

- 선언하지 않은 식별자에 접근할 경우 ReferenceError(참조에러)가 발생한다.
  (자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러)



## 변수 선언의 실행시점과 변수 호이스팅

```javascript
console.log(score); // undefined

var score; // 변수 선언문
```

위의 예제를 보면 변수 선언되기 전에 변수를 참조하였기 때문에
referenceError가 발생할것같지만, 실제 console.log에서는 undefined를 출력한다.

그 이유는 변수 선언이 소스 코드가 한 줄씩 순차적으로 실행되는 시점, 
**즉 런타임(run-time)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**

1. 자바스크립트 엔진은 코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 코드의 평가 과정을 거치면서 
   코드 실행을 위한 준비를 한다. 
2. 이때, 즉 코드 실행을 위한 준비 단계인 코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 코드에서 찾아내어 먼저 실행한다. 
3. 그리고 코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 코드가 한 줄씩 순차적으로 실행한다.

이처럼 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)**이라 한다.



## 값의 할당

변수에 값을 할당할 때는 할당연산자(=)를 사용한다.
우변의 값을 좌변의 변수에 할당한다.

```javascript
var score;  // 변수 선언
score = 80; // 값의 할당

// 하나의 문으로 아래와 같이 단축
var score = 80; // 변수 선언과 값의 할당
```



변수 선언은 소스 코드가 순차적으로 실행되기 이전, 
즉 런타임 이전에 먼저 실행되지만 **값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**

```javascript
console.log(score); // undefined

var score = 80;     // 변수 선언과 값의 할당

console.log(score); // 80
```

즉, 변수의 선언과 값의 할당을 하나의 문장으로 단축 표현해도 **자바스크립트 엔진은 변수의 선언과 값의 할당을 분리해서 각각 실행한다는 의미이다.** 따라서 변수에 `undefined`가 할당되어 초기화되는 것은 변함이 없다.
(= 새로운 메모리 공간을 확보하고 그 메모리 공간에 할당 값 80을 저장하는 것!)



## 값의 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.
- var 키워드로 선언한 변수는 값을 재할당할 수 있다. 
  재할당 할 수 있으므로 변수라 부른다. 
  (단 한번만 할당할 수 있고 재할당을 할 수 없어 변수에 저장된 값을 변경할 수 없다면 그것은 **상수(constant)** 이다.)

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90;     // 값의 재할당
```

전 값 80이 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 재할당 값 90을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 숫자 값 90을 저장한다
(= 80과 90의 메모리주소는 다르다.)

현재 변수 score의 값은 90이다. 변수 score의 이전 값인 undefined과 80은 어떤 변수도 값으로 갖고 있지 않다. 이것은 undefined과 80이 더이상 필요하지 않다는 것을 의미한다. 아무도 사용하고 있지 않으니 필요하지 않은 것이다. 이러한 불필요한 값들은 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될 지는 예측할 수 없다. (이를 통해 메모리 누수(memory leak)를 방지한다.)



***언매니지드 언어와 매니지드 언어***

> 프로그래밍 언어는 메모리 관리 방식에 의해 
> 언매니지드 언어(Unmanaged Language)와 매니지드 언어(Managed Language)로 분류할 수 있다.
>
> **언매니지드 언어(C 언어..)**
> 개발자가 명시적으로 메모리를 할당하고 해제하기 위해 malloc()과 free()와 같은 저수준(low-level) 메모리 관리 기능을 제공한다. 언매니지드 언어는 메모리 관리를 개발자가 주도하므로 개발자의 역량에 의해 **최적의 퍼포먼스를 확보할 수 있지만 그 반대의 경우, 치명적 오류를 생산할 가능성**도 동시에 존재한다.
>
> **매니지드 언어(자바스크립트..)**
> 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다. 즉, 개발자가 명시적으로 메모리를 할당하고 해제할 수 없다. 더 이상 사용하지 않는 메모리의 해제는 가비지 컬렉터(Garbage Collector)가 수행하며 이 또한 개발자가 관여할 수 없다. 매니지드 언어는 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느 정도 **일정한 생산성을 확보할 수 있는 장점이 있지만 퍼포먼스 면에서의 손실은 감수할 수 밖에 없다.**



## 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, underscore( _ ), 달러 기호($)를 포함할 수 있다.
- 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다.



***가능은하지만 권장하지 않은 네이밍***

- 쉼표(,)로 구분해 하나의 문에서 여러 개를 한번에 선언하는 경우

  > 가독성이 나빠지기 때문

- 유니코드 문자



***주의할 점***

- 자바스크립트는 대소문자를 구별해라

  > ```
  > var firstname;
  > var firstName;
  > var FIRSTNAME;
  > ```
  >
  > 위의 변수는 각각 다른 변수이다.

- 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해라

  > 좋은 변수 이름은 코드의 가독성이 높인다.
  >
  > 즉, 변수 선언에 별도의 주석이 필요하다면 변수의 존재 목적을 명확히 드러내지 못하는 것이다.



하나 이상의 영어 단어로 구성된 식별자를 네이밍할 때 단어를 한눈에 구분하기 위해 자주 사용되는 네이밍 컨벤션은 아래와 같이 4가지가 있다.

```javascript
// 카멜 케이스 (camelCase)
var firstName;

// 스네이크 케이스 (snake_case)
var first_name;

// 파스칼 케이스 (PascalCase)
var FirstName;

// 헝가리언 케이스 (typeHungarianCase)
var strFirstName;          // type + identifier
var $elem = $('.myClass'); // jQuery
```

일관성을 유지한다면 어떤 네이밍 컨벤션을 사용하여도 좋다. 
가장 일반적인 것은 **변수나 함수의 이름에는 카멜 케이스**를 사용하고 **생성자 함수, 클래스의 이름에는 파스칼 케이스**를 사용하는 것이다.