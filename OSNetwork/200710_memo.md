# DAY 3

## 인터럽트

**인터럽트** : 중간에 들어오는 것

자바스크립트에서 비동기

CPU가 PC를 읽어드려 라인을 실행하고 +1
실행이 되고있는 와중에 스캐쥴러가 언제 탁! 멈출것인가?
스케쥴러도 결국 CPU에서 실행하는 코드
중간에 키보드를 눌렀을 때, 어떻게 감지해서 실행시킬것인가?

**이를 처리하는기술을 인터럽트라고 한다.**

**선점형 스케쥴러 :** 

운영체제가 실행권한을 뺏어오는것

**비선점형 스케쥴러 :**

스캐쥴러가 A,B,C 중에 a를 실행하게 했다. 
끝나는 조건 : IO를 사용하거나 / 혹은 100ms가지나서 강제로 종료되거나 
다끝났을때만 다른프로세스로 교체할 수 있다.

요즘은 보통 선점형 스케쥴러이다. => 인터럽트 때문이다.

> IO : 
>
> 입출력 하드웨어(= IO)
>
> 인터럽트 : 
>
> 다른 디바이스에서 CPU에 이벤트를 주는 기술



한번 운영체제가 a라는 프로세스에 제어권이 넘겨주면 중간에 막을 수 있는 방법이 없어서 그거때문에 인터럽트가 나오게 되었음

컴퓨터 메인보드에 보면 CPU, memory 꽂는 란이 있다.

조그마한 부품, 타이머를담당하는 칩이있는데 일정시간마다 신호를 보내주는 역할을 한다.

신호를 보낼 때(특정 주소에 신호를 보냄) 주소에 신호가 들어오면 운영체제에서 주소에 해당하는 함수를 호출되도록 만들어져있다. 신호가 들어오면 이 cpu가 실행하는것이 아니라 이벤트를 받아서 운영체제로 pc로 바껴지면서 함수를. 실행하게된다. (리눅스 기준 : 10ms 당 한번씩)
100ms마다 스캐쥴러가 실행된다. (i = i + 1 / if (i < 10)) ...

인터럽트 번호에 따라서 어떤함수가 실행할지 기제되어있고
그 함수에 가서 위와같은 간단한 반복문 작업을 하고 100번이 넘어가면 run schedule하고 스케쥴알고리즘을 돌리고 그다음 선택할 프로세스를 선택해서 컨텍스트 스위칭이 일어나서 cpu에서 프로세스를 실행하게 된다.

컨텍스트 스위칭 하기전에 하는 일이 타이머에 있는 i값을 다시 0으로 만든다.
10이되면 스캐쥴러를 띄우고 / 프로세스를 선택하고 ... (반복)

i를 증가시킬때 운영체제에 권한이 주어지기 때문에 
이것을 스케쥴러가 선점한다해서 **선점형 스케쥴러**라고 한다.

cpu는 항상 pc에있는걸 계속 실행하는거고
중간에 pc값을 바꿔서 cpu는 실행하고
인터럽트 날라오고...

인터럽트는 보드에서부터 위로위로 올라와서 자바스크립트로 올라오는게 비동기작업의 시초이다.

프로세스가 ready => running상태 가다가 wating(blocked)에 큐에 넣는 상태일때

Q : a가 웨이팅상태일때 IO 끝난다음에 어떻게 알려줘?
A : 인터럽트를 보낸다.
운영체제가 인터럽트를 받아서 a가 IO가 다 끝났구나 하고
스케쥴러가 다시 ready상태로 바꿔준다.

키보를 딱 치면 인터럽트로 들어가서 인터럽트를 처리하기위한 함수가 돌면서 프로세스를 바꿔줄 수 있다.
프린터도 프린팅이 다 끝나면 운영체제가 컴퓨터에게 알려준다.
네트워크도 데이터를 받았다고 알려줘야한다

이 모든것이 인터럽트 메커니즘을 가지고 처리를 한다.



만약 0으로 나눌경우 

=> CPU가 실행하는 와중에 계산이 안되가지고 error가 나는것
그 에러는 cpu가 실행하다 못해서나는 에러이기때문에
cpu가 인터럽트를 보낸다. "Devide-by-Zero Interrupt" 그럼 운영체제가 종료시켜준다.



주요 인터럽트 : 타이머 / IO (외부 인터럽트)

32bit 2의32승까지 표시할때 이를 곱했는데 계산결과가 overflow가 될경우



내부 인터럽트 : 소프트웨어 인터럽트
외부 인터럽트 : 하드웨어 인터럽트

Link-in



시스템 콜 인터럽트

사용자모드에서 커널모드로 내려간다.
어떻게 실제로 가능한가?

실행한 코드가 어떻게 구현이 되는지 내부적으로 봐보면

cpu에 여러가지 레지스터가 있고, 그안에 번호를 넣고
값을 넣어준다. 

인터럽트를 받자마자 사용자모드에서 커널모드로 바꿈
시스템 콜도 결국 인터럽트로 움직인다.

갑자기 바뀌는게 아니라 코드상에서 특정한 인터럽트를 보내는데 특정한 레지스터라는 저장매체에 값을 넣어서 인터럽트를 보낸다. cpu => 커널모드로 바꾸고 해당하는 함수를 실행시킨다.

컴퓨터에서 프로그램을 실행시킬때 스무스해보이지만
실제로 내부에서는 굉장히 많은 작업들이 된다.

ex) 프로세스 a가 실행되면 100ms기간에

이동안 cpu에서 10ms기준으로 인터럽트를 보내어 타이머처리(운영체제쪽)를 하여 왔다갔다한다. 그 중에 io, 시스템콜 호출할때마다 다시 인터럽트를 팅겨서 커널모드를 왔다갔다한다.

커널모드 사용자모드를 왔다갔다하면서 프로그램을 실행



인터럽트 테이블 : 매칭테이블 => 메모리에
메모리에 운영체제가 부팅할때 넣어준다.

코드 바이너리코드 프로세스에 올라가고 스케쥴러에 담겨져서 실행을 하는데 이터럽트로 팅기고(타이머) 그때마다 커널/사용자모드 왔다갔다 하고 시스템콜이호출되면 커널모드로 들어간다.

---

## 가상메모리

PC에있는 메모리를 생각하면 프로세스를 여러게 띄워도 문제가 없는이유가 가상메모리 때문이다.

가상주소

모든주소는 0~4GB
CPU가 있고 이 안에서 pc가 메모리 주소값을 가리킨다.
pc의 값을 다른데다 쓰거나..

mmu

우리가쓰는 코드가 10mb까지가기어렵다 주로 kb단위
프로세스마다 4gb공간이 주어지니깐 대부분이 빈공간이다.
지금실행하는코드는 엄청 작은크기일것이다.
프로세스있는 4gb를 다 할당하는것이아니라 필요한 부분만 할당하는것이다.
(물리메모리) 그럼 다 동작하는 형태로 된다.

어느코드를 올릴것인가, 빈공간을 찾아서 넣어야하는대 그렇게되면
주소가 다 달라지기때문에 CPU입장에서 단순하게 0~4gb의 가상주소로 다루고 그 주소를 찝었을때 물리메모리에있는 주소로 변환시켜서 그것을 가져오는게 별도의 칩이 해주는데 이것에 mmu이다.

이렇게하는이유 : 메모리가 몇gb든, 프로세스가 여러가지더라도 다 처리할 수 있다. 충분히 가능하다.

ex) 자기가 쓰고있는 프로그램, 한글, mp3를 띄웠을 때, 메모리가 4gb더라도 상관없을것이다. 그런데 영상편집도하고 게임도하고 ...등등 여러가지를 하게되면 꽉차게 되는경우가 생길것이다. (메모리를 늘려줘야함)

가상메모리라는 기본적인 컨셉은 가상주소를 다룬다.
데이터 읽고 쓸때만 물리주소로 바꾸어준다.(실제 메모리 주소)

물리주소 : 실제메모리주소

페이징 시스템

아이디어는, 물리적주소를 직접다루지 않고 가상주소로 다루고 그다음에 모든내용이 들어가있지 않고 필요한 부분만 위에 올려놓고 사용한다. = 컨셉

이것을 구현하기 위해서 크게 paging system이있다.(segment system도있는데 요즘엔 잘 사용하지 않는다.)

가상메모리! 하면 paging system

페이징시스템은

프로세스를 특정메모리에 올려놓는다한것을
여러가지 생각할것들이 있다. 얼마만큼? 범위는? 코드블럭? 파일단위? ...

심플하게 4kb단위 혹은 1kb, 2gb 단위로 정해놓았다.
CPU에서 지원해줘야한다.
(고정된 핸들링할 사이즈를 운영체제에서 정해줘야한다.)

리눅스는 4kb **페이징시스템은 고정된사이즈로 왔다갔다 한다**.

**(엑셀 예시)**

> 00000000h (헥사)
>
> 프로세스 처음실행했을때는 
>
> 프로세스의 페이지번호와 최상단주소에서 얼만큼떨어져있는지(변위)
>
> 이주소를 담고있는 빨간페이지의 페이지는 몇번이냐, 맨위의 주소는 몇번이냐 페이지테이블에서 물리주소를 알아내고 프로세스에서 몇번떨어져있는지 알면 물리메모리에서 정확하게 선택해서 가져올 수 있다.
>
> 테이블에 해당페이지가없으면 인터럽트를 날려준다.
> 그럼 운영체제가 프로세스에있는 페이지를 물리페이지에 넣어준다.
> 다시 CPU에 요청하면, 페이지의 주소를 호출한 페이지의 번호를 페이지 테이블에 확인하고, 물리주소에 변위만큼 더한것을 물리멤리에서 찾아서 가져온다.
>
> 이 과정을 계산해주는것이 **MMU**



실제 가상메모리 컨셉은
실제사용하는 메모리는 작다. CPU에서 실행하는건 적다.
어느순간 CPU가 접근하고 있는 코드는 한정되어있는 컨셉때문에 가상메모리가 나왔고, 메모리가 실제메모리보다 크게보이게끔 되어있음

가상주소 / 물리주소로 나눠서 관리하고, 매번 변환하기 힘드니깐 MMU를 사용한다. CPU는 가상메모리를 요청한다.
(Segment page는 고정되지않은 크기)

페이지를 왔다갔다하기위해 CPU도움을 받는다. (사이즈를 지원해줌)

각각의 프로세스마다 페이지 테이블은 메모리에있다.
각각의 프로세스마다 있다.
페이지 맨 위에있는주소 => PCB에 있다.

프로세스마다 이런 페이지테이블을 관리한다.

가상주소 : 가상 메모리 페이지에
페이지 위에서 변위만큼 더해줌

64bit / 32bit로 다루느냐의 차이일 뿐, 속도의 차이는 없다.



MMU에게 pc주소를 던지면, MMU가 어떻게 물리주소를 알아내느냐?

일단 페이지 테이블을 찾아가야함. / 각 프로세스마다 있음

페이지테이블은 메모링있음 페이지테이블의 최상위주소
컨텍스트 스위칭 할때 pc. sp값 덮어씌워줄때, CR3라는 래지스터도 덮어씐다.
cr3는 페이지테이블의 최상위 주소를 가지고 있다. 
해당페이지테이블 주소를 가지고 물리적주소로 가져온다.

페이지테이블은 언제 만들어지나?

페이지 테이블은 프로세스 운영체제에서 코드상태에서 메모리로 프로세스가 올려진다. (다 올라가는게 아니라 맨처음에 일부만 올라간다.)

ex) 8kb만올려놔 거기서부터 시작해..라고설정

그때 페이지테이블을 생성하고 그정보를 PCB에 CR3에 넣는다.
페이지 테이블 전체가 4gb면 1024로 나눠야 4kb정도되고..
시간이 많이 걸리지 않을까? 

페이지테이블을 다 만드는건 시간이 많이 걸려
일부만 만들고, 나머지 관련데이터가 올릴때 그때 올라감 = 빨리 실행됨

그래서 다중 단계 페이징 시스템이 나왔다(참고)

cpu에 레지스터는 한방에 가져오지만
memory만해도 200 cycle인데

원사이클을 요청했는데 200사이클이 걸리면 오래걸린다.

이래서 나온게 TLB이다.

TLB : 캐쉬 mmu에 물리주소를 가져오면 한참 페이지테이블을 가서 가져와야하는데 기존에 가져왔던 데이터는 tlb라는 별도의 칩을 저장한다.
=> 속도개선

MLB / TLB를 알려면 해당5단계사이클 구조와 가상메모리를 알아야한다.

가상메모리 물리메모리 따로이루어져있다.
그 메모리를 접근하려면 페이지테이블에 가야한다.

프로세스와 프로세스는 커널공간을 공유한다.
커널공간은 하나있고 페이지테이블에서 가리키고있으면 되므로
이를통해 공유가 가능하다.

**메모리에 얼마만큼올리고 어떤것을 올려야하나?**

demanded paging : CPU가 요청할 때 올린다.

장점 : 메모리를 효율적으로 사용할 수 있다.
맨처음에 올리는 시간이 필요함.

CPU가 프로세스 내에 다른 함수를 실행해야 할 경우 : demanded paging 한다.

> 반대개념 : 선행페이지(프로세스에 모든데이터를 올려놓고 cpu에서 실행하는 방식)



## Page fault

"나 이거 실행해야되 mmu야 가상메모리 주소줘!"

mmu가 페이지테이블에 vaild-inaild bit 가 i로 되면 인터럽트를 보낸다.

해당데이터를 가지고 메모리에 가져와서 cpu에서 처리한다.

> cpu가 mmu에 가상메모리 주소 요청 =>
>
> mmu가 cr3에있는 테이블에가기전에 tlb에 가상주소가있는지 보고 메모리에 페이지에가서 주소를 가져와
>
> 만약 페이지테이블에 없어 그럼 페이지 폴트를 내서 os에 인터럽트를 내고



페이지폴트가 자주일어날 경우

- 프로그램은 느려질 수 밖에 없다.

- 안일어나게 하려면? => 실행할만한 코드를 미리 올려놓는다.

  **페이지 교체 정책**



## 페이지 교체 정책 

FIFO / OPT / LRU / LFU / NUR 

CPU가좋아질수록 파이프라인갯수가증가한다(현재 16개정도)

파이프 / 싸이클

