# DAY 2

스케쥴러라는 개념이 나오면서 OS가 더욱 중요해졌다.

**FIFO**(first in first out) : Queue

> A - B - C
>
> 실행 : A - B - C(각각 1시간일경우)
>
> 시분할시스템을 지원해야함
>
> 100ms단위로 a - b - c - a (RR(라운드로빈))로 돌리면 시분할시스템으로
>
> 멀티캐스팅이 가능함

**SJF** : 가장짧은시간 먼저

RealTimeOS : 반도체, 프로그램 실행시간이 얼마나 걸리는지 정확히 알 수 있다.
(일반 OS는 안됨)

> 반대개념 : GPOS 
>
> 우리가 사용하는 OS



**Priority-Based** :우선순위기반

모든 알고리즘을 작성할때, 위에대한얘기가 한번씩 언급된다.
이런알고리즘이 있다.



그럼 실제 사용하고있는 현대 스케쥴링 알고리즘은 무엇인가?

**프로세스 상태 기반 스캐쥴러**

> A - B - C 를 실행해
>
> 1. ready Queue에 등록
>    레디큐에 프로세스가 있는지 확인
>    맨 앞에있는걸 빼온다.
>
> 2. running queue
>
>    위에 빼온 큐를 러닝큐에다 넣어놓는다.
>    cpu에 지금실행하고 있는것
>
>    프로세스가 다른프로세스가 교체되는 조건 : 
>    100ms돌고 교체한다, 중간에 하드디스크에서 무엇을 작업한다.(IO)
>
>    50ms에 돌고있는데 갑자기 io가 발생했다 => blocked queue에 넣는다
>
>    그냥 100ms가 다 돌면 바로 ready queue로 들어간다.
>
> 3. blocked queue
>
>    IO가 다 끝나면 running queue가 알려주고, 
>
>    blocked queue에 있던 큐가 다시 레디큐로 돌아가다.
>
> 라운드로빈으로 계속 반복
> 조건문과 반복문으로 계속 돌고있음
>
> **멀티프로그래밍과 시분할시스템이 가능해짐**

큐가 중요하게 다뤄진이유가 운영체제에서 위와같이 사용되기 떄문이다.
어떻게 저장해서 심플하게 가져올것인가.

큐라는 알고리즘을 사용하고 + 조건문 반복문으로 이루어져있다.
이런 알고리즘을 기반으로 아주 복잡하게 진화했다.



네트워크 : IO-bound

Redis : NoSQL / 메모리에서만 작업하기때문에 성능이 빠르다. / 그래서 cache로 많이 쓴다.

> Ex) 로그인, 아이디정보를 쏵 가져와서..

mongoDB, mySQL은 파일에서 작업
(취업후 알아보면 좋을것)



프로세스 (바이너리로 되어있는 exe를 메모리에 올린다.)

stack : 함수안에서 함수를 호출하면 함수안에 지역변수들을 저장함

Heap : unmanaged언어에서 볼 수 있음 / 변수에 정수로 만든 크기만큼의 공간을 할당한다.(heap에 저장됨)



프로세스 공간은 실행할때 4GB정도 메모리에 할당됨(리눅스 기준)
stack / heap 공간은 제한되어있다.

그래서 가비지컬렉션이 나왔다.
(Heap이 꽉차면안되니깐 주기적으로 지금 참조가 안되어있는 객체를 지워버린다.)

컴파일된 프로그램을 실행시키면 process에 들어감

DATA : 초기화된 변수
BSS : 초기화되지않는 변수
STACK : return값(code안에있는 함수가 끝나는시점의 주소값)
CODE : 코드

프로그램을 실행시켰을때 빨리 되어야함
그래서 속도를 개선시키기 위해 위와같이 분리되어있음

pc에있는 주소값을 가져와 CPU는 실행된다.
주소값을 가져오고 pc는 값이 참조될때마다 +1 된다.(반복)

스택포인트(SP) : 항상 위를 가르킴
다른프로그램으로 실행하다가 다시 이어서 실행할 수 있게 해줌

힙에있는데이터를 수시로삭제해줘야하기위해서 가비지컬렉터가 필요함



컨텍스트 스위칭 : 

cpu에서 프로세스를 실행하려면 pc와 sp가 필요하고
pc(program counter)와 sp(stack pointer)가있으면 문맥교환이 가능해짐



웹브라우저도 하나의 프로세스이다.
v8엔진은 일종의 스크립트를 지원해주는 기능이다.
객체지향언어니깐 객체에 memory heep이라는 객체가있고
이곳에서 메모리 할당이 일어난다.

memory heap / call stack
stack영역도 일정 size가 있다.



가상메모리기술



어떤프로세스를 가리킬때는 0 ~ 4GB 사이에 특정주소를 가르키게되어있다.
멀티쓰레딩 / 프로세스(프론트에서는 잘 안함)

실행의속도를 높이려면 동일한 프로그램을 만들거나 멀티쓰레딩을 해야한다.
(동시에 접속이 가능하는지 / 몇명까지 동시접속이 가능하는지에대한 관점)

여러프로세스를 사용하게되면 특정데이터를 공유하고 받아야할 경우가 있는데
프로세스에서 프로세스가 접근이 안되므로 IPC라는것을 사용한다.

IPC : a에서 사용한 변수값을 b에 알려주고싶다 => 파일을만들어서 b에서 읽어드림
단점 : 실시간이 안됨

---

heap : 동적메모리

프로세스 교체
지금돌고있는 PC / SP 저장 => pc위에 저장 / 다음으로 실행할 프로세스(스케쥴러에의한)

프로세스간 데이터공유가 안되서 ICP / 컨셉 : 커널메모리공유

---

자바스크립트로 작성 => 브라우저에 띄운다 가정

본래는 컴파일 => 저장매체에 저장

쉘로 실행 => 프로세스 4gb할당 (stack /heap / data / code)

프로세스 실행은 운영체제가 관장한다 => 스케쥴러

레디큐로 가고 러닝큐 pcb정보에서 pc / sp를 가져옴

---

## Thread

멀티프로세스 / 멀티쓰레드 

쓰레드는 프로세스안에서 생성할 수 있고
쓰레드가 생성될때마다 스택이 생성된다.

쓰레드는 하나의 함수이다.

프로세스 안에서 쓰레드가 생성되고 동작한다.

쓰레드간 데이터를 공유가 가능하다.

쓰레드는 각각마다 가지고있는 개별스택도 가지고있다. (프로세스 스택안에서)

쓰레드를 생성한 프로세스(부모프로세스) 데이터 힙 .. 변수를 공유한다.



멀티 태스킹 / 멀티 프로세싱

목적은 다르나 기능이 비슷하다.

cpu core : 프로새스를 쓰레드로 만들어서 cpu core에 던진다. (실행속도 빨라짐)

쓰레드가 언제스캐쥴링되어질지 모를때 결과값기 예상과달리나올 수 있다(쓰레드 동기화 문제)
해결하기 어려움(대부분 간헐적으로 일어남) => 디버깅이 어려움, 재현해야하는데 간헐적이라

=> 앞,뒤로 locking 작업을 해준다.

코드힙데이터 공유 / 크리티컬 리소스를 읽고쓰다보면 문제가 발생할 수 있으니. mutual exclusion을 사용한다.

Apache / ngnix

---

프로세스안에있기때문에 프로세스안에있는 자원들을 다룬다.

Thread 동기화

- mutex

  임계영역에 thread가 하나만 들어갈 수 있다.

- semaphore

  임계영역에 두개정도 동시에 들어올 수 있음

동기화를 잘못 사용하게되면 

서로 임계영역이 겹쳐서 deadlock 발생할 수 있음

---

멀티프로세스는 구조를 바꿔야함 / 안정성을 위해서 사용해도 좋음
쓰레드로인한 동기화문제가 많이생기면 멀티프로세스를 사용

뮤텍스/세마포어 : 임계영역에 들어가는 쓰레드 갯수 차이

