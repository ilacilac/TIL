# DAY 4

## 프로토콜

각각의 단계가 있어야하고
각각의 역할

이를 논의한 국제표준화기구 : ISO

기능들을 정의만 해놓음 (OSI 모델 / OSI 7 layer)

http 요청 => 실제데이터앞에 header을 붙여서 전송된다(물리적으로, LAN)
받는쪽에서는 header 앞에부분 처리하고 위로위로 올려서 요청에대한 데이터를 가져오게된다.

http request를 보낼때 header / body로 이루어져있는게 이 부분이다.

**캡슐화 / 역캡슐화**

맥어드레스 : 랜카드에 고유하게 발급한 번호
랜(근거리 네트워크) / 기기 끼리의 통신의 역할로 남겨짐

Ip address : 네트워크 안에 네트워크를 넘나들으면서 주소를 찾아가는 기법
Ip 프로토콜 버전

요청을 할때 포트번호를 셋팅해서 요청을 보낸다.
프토토콜 안에 전송계층의 헤더부분을 보고 포트번호를 알수있다.

=> 해당 프로그램에게 요청을 보낸다. 
어떤 응용프로그램에 데이터를 전달해야하는지 식별가능

포트는 전송계층에서 셋팅한다.

OSI 7 layer => 프로토콜을 알고있는것인지 물어보는것 

TCP / IP모델 

IP : IPv4, 32bit(8bit, 8bit, 8bit, 8bit)
IPv6 : 128bit / 너무 주소가길어서 데이터헤더가 길어짐(전송속도느려짐)

**TCP** / UDP

```
node tcp_server.js
node tcp_client.js

wireshark : tcp.port == 9999
```

---

운영체제 주요목적 : 컴퓨터의 하드웨어를 관리하는 것이다.

운영체제는 컴퓨터 성능을 높이고 사용자에게 편의성 제공을 목적으로하는 컴퓨터 하드웨어 관리하는 프로그램이다.

Processor(일반적으로 CPU)

Main memory

- ROM : 비휘발성, 메모리에서 극히 일부(KB)

  POST(Power-On Self-Test) / 부트 로더(boot loader)

  POST : 전원이 켜지면 가장 처음에 실행되는 프로그램

   			현재 컴퓨터의 상태를 검사

  boot loader : POST작업이 끝나면 실행

  부트 로더는 하드디스크에 저장되어있는 운영체제를 찾아 메인 메모리에(RAM) 가지고 온다.

  이러한 부트 로더의 과정을 **부팅**이라고 한다.

- RAM : 휘발성, 메모리의 대부분을 차지하며 실제 프로그램이 할당되는 곳

부트 로더가 진행한 상태 : 운영체제가 수행할 준비를 마침
운영체제가 종료하는 시점 : 컴퓨터의 전원이 꺼지는 시점

운영체제

- 커널(kernel)
  - 운영체제의 핵심, 운영체제가 수행하는 모든 것이 저장되어있다.
- 명령어 해석기(Command interpreter shell)
  - 커널에 요청하는 명령어를 해석하여 커널에 요청하고 그 결과를 출력

사용자는 GUI / CLI 같은 방식으로 운영체제에 명령을 요청할 수 있음

> ex) 현재 디렉토리의 파일리스트 불러오기 / 프로그램 실행하기 / 디스크 용량 확인 ...



사용자 프로그램(application)은 특정 운영체제에 맞춰서 만든다.
그러므로 한 애플리케이션은 서로 다른 운영체제에서 수행할 수 없다. 
(하드웨어가 같은 것은 전혀 상관없다.)

>  ex) windows에서 수행하는 프로그램을 그대로 Linux에 옮기면 수행되지 않음



CPU 스케쥴링 :
CPU가 어느 프로그램을 수행하는지 선택하는 것

시분할 시스템 : 

- CPU가 하나의 프로그램을 수행하는 시간을 제한하는 것

- 여러 사용자(프로세스)간에 통신이 가능해졌다.

  하지만 여기서도 역시 멀티 프로그래밍에서와 같은 스케줄링과 메모리 문제가 있었다.

  이를 해결하기 위해 동기화 기술, 가상 메모리 등이 이후에 나왔다.

> ex) User1 프로그램을 일정 시간 수행하면 바드시 다음 프로그램으로 넘어가서 또 다시 일정시간을 수행한다. 이렇게 일정 시간을 두어 프로그램들을 번갈아 수행하면서 모든 프로그램이 공평하게 수행이 되도록 한다. 그리고 이 일정시간은 매우 짧은시간이므로 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져온다.



현재 운영체제는 인터럽트 기반 시스템이다.

Q : 마우스를 움직이는 동작을 컴퓨터는 어떻게 알 수 있을까?

A : 인터럽트를 통해 알 수 있다. 마우스를 움직이는 순간, 마우스에서 인터럽트 전기 신호가 발생하여 이를 CPU에게 보낸다. CPU는 이를 감지하고, 자신이 하던 일을 멈춘 후에 이 인터럽트 신호를 처리하기 위해 운영체제 내부에 있는 인터럽트를 처리하는 코드(interrupt service routine, ISR)로 이동한다.

**하드웨어 인터럽트 :** 하드웨어에서 발생한 인터럽트
**소프트웨어 인터럽트 :** 명령어로 직접 인터럽트 전기 신호를 CPU에게 보낼 수 있다. 즉, 프로그램에서 `swi`, `int` 와 같은 어셈블리어 명령어를 수행하는 것이다. (명령어는 운영체제마다 다르다.)
**내부 인터럽트 :** 프로그램을 수행하는 도중에 발생하는 예외상황을 처리한다.

> ex) 0을 나누는 동작 => CPU는 내부 인터럽트를 발생시켜 운영체제 안에 있는 ISR로 이동한다. 이 경우에는 `DivideByZero` 라는 ISR로 이동한다. 
>
> 여기서 잘못된 동작을 수행한 프로그램을 강제로 종료한다.



운영체제는 평소에는 대기 상태에 있으면서 인터럽트가 발생하는 순간 작업을 수행한다.
그 인터럽트의 종류에 따라 운영체제 내부에 위치한 ISR로 이동하여 그에 맞는 처리를 한다.

- **인터럽트**는 CPU에게 보내는 전기신호
- 인터럽트가 발생하면 CPU는 하던 일을 중지하고 해당 인터럽트를 처리하기 위해 운영체제 내부에 있는 ISR로 이동하여 수행한다.
- 수행이 끝나면 원래 위치로 돌아간다.

